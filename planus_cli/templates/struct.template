#[derive(Copy, Clone, Debug, PartialEq, PartialOrd)]
pub struct {{ info.owned_type }} {
    {% for info in field_infos -%}
        pub {{ info.owned_field_name }}: {{ info.owned_field_type }},
    {% endfor %}
}

impl planus::Primitive for {{ info.owned_type }} {
    const ALIGNMENT: usize = {{ decl.alignment }};
    const SIZE: usize = {{ decl.size }};
}

#[allow(clippy::identity_op)]
unsafe impl planus::WriteAsPrimitive<{{ info.owned_type }}> for {{ info.owned_type }} {
    unsafe fn write(&self, buffer: *mut u8, buffer_position: u32) {
        {% for (info, f) in field_infos.iter().zip(decl.fields.values()) -%}
            self.{{ info.owned_field_name }}.write(buffer.add({{ f.offset }}), buffer_position - {{ f.offset }});
        {% endfor %}
    }
}

impl planus::WriteAs<{{ info.owned_type }}> for {{ info.owned_type }} {
    fn prepare(&self, _buffer: &mut planus::Buffer) -> {{ info.owned_type }} {
        *self
    }
}

impl planus::WriteAsOptional<{{ info.owned_type }}> for {{ info.owned_type }} {
    fn prepare(&self, _buffer: &mut planus::Buffer) -> Option<{{ info.owned_type }}> {
        Some(*self)
    }
}

#[derive(Copy, Clone)]
pub struct {{ info.read_type }}(&'buf [u8; {{ decl.size }}]);
impl<'buf> {{ info.read_type }} {
    {% for (info, f) in field_infos.iter().zip(decl.fields.values()) %}
        pub fn {{ info.read_name }}(&self) -> {{ info.read_type }} {
            let buffer: &[u8; {{ f.size }}] = std::convert::TryInto::try_into(&self.0[{{ f.offset }}..{{ f.offset + f.size }}]).unwrap();
            {% match f.type_ %}
            {% when SimpleType::Enum with (_) %}
                planus::TableRead::from_buffer(planus::BufferWithStartOffset { buffer: &*buffer, offset_from_start: usize::MAX }, 0).map_err(|error_kind| {
                    planus::Error {
                        source_location: planus::errors::ErrorLocation {
                            type_: "{{name}}".into(),
                            method: "{{info.read_name}}",
                            byte_offset: usize::MAX,
                        },
                        error_kind,
                    }
                })
            {% when SimpleType::Struct with (index) %}
                self::{{info.read_type_no_lifetime}}(buffer)
            {% when SimpleType::Integer with (typ) %}
                {{info.read_type}}::from_le_bytes(*buffer)
            {% when SimpleType::Float with (typ) %}
                {{info.read_type}}::from_le_bytes(*buffer)
            {% when SimpleType::Bool %}
                buffer[0] != 0
            {% endmatch %}
        }
    {% endfor %}
}

impl<'buf> std::fmt::Debug for {{ info.read_type }} {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("{{info.owned_type}}")
        {% for info in field_infos.iter() -%}
            .field("{{info.read_name}}", &self.{{info.read_name}}())
        {% endfor %}
        .finish()
    }
}

impl<'buf> planus::ToOwned for {{ info.read_type }} {
    type Value = {{ info.owned_type }};
    fn to_owned(&self) -> planus::Result<Self::Value> {
        Ok({{ info.owned_type }} {
        {% for (info, f) in field_infos.iter().zip(decl.fields.values()) -%}
            {%- match f.type_ -%}
                {%- when SimpleType::Struct with (path) -%}
                    {{ info.owned_field_name }}: planus::ToOwned::to_owned(&self.{{ info.read_name }}())?,
                {%- when SimpleType::Enum with (path) -%}
                    {{ info.owned_field_name }}: self.{{ info.read_name }}()?,
                {%- else -%}
                    {{ info.owned_field_name }}: self.{{ info.read_name }}(),
            {%- endmatch -%}
        {%- endfor %}
        })
    }
}

impl<'buf> planus::TableRead<'buf> for {{ info.read_type }} {
    fn from_buffer(buffer: planus::BufferWithStartOffset<'buf>, offset: usize) -> Result<Self, planus::errors::ErrorKind> {
        let buffer = buffer.advance_as_array::<{{decl.size}}>(offset)?;
        Ok(Self(buffer))
    }
}
