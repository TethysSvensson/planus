#[derive(Clone, Debug)]
pub struct {{ info.owned_name }}{
    {% for field in fields.declaration_order() -%}
        pub {{ field.info.name }}: {{ field.info.owned_type }},
    {%- endfor -%}
}

impl {{info.owned_name}} {
    pub fn create(
        buffer: &mut planus::Buffer,
        {% for field in fields.declaration_order() -%}
            {{ field.info.create_name }}: impl {{ field.info.create_trait }},
        {% endfor %}
    ) -> planus::Offset<Self> {
        {% for field in fields.declaration_order() -%}
            let prepared_{{ field.info.create_name }} = {{ field.info.create_name }}.prepare(buffer);
        {% endfor %}

        let mut table_writer = planus::table_writer::TableWriter::<{{(max_vtable_index+2)*2}}, {{max_size-4}}>::new(buffer);

        {% for field in fields.declaration_order() %}
            if prepared_{{field.info.create_name}}.is_some() {
                {%- if field.field_type == BackendTableFieldType::UnionValue -%}
                table_writer.calculate_size::<u8>({{2 * (field.vtable_index)}});
                {%- endif -%}
                table_writer.calculate_size::<{{field.info.vtable_type}}>({{2 * (field.vtable_index + 1)}});
            }
        {% endfor %}

        {% if !fields.is_empty() %}
        unsafe {
            {% for field in fields.alignment_order() %}
                if let Some(prepared_{{field.info.create_name}}) = prepared_{{field.info.create_name}} {
                    {%- match field.field_type -%}
                    {%- when BackendTableFieldType::UnionKey -%} table_writer.write({{field.vtable_index+1}}, &prepared_{{field.info.create_name}}.tag);
                    {%- when BackendTableFieldType::UnionValue -%} table_writer.write({{field.vtable_index+1}}, &prepared_{{field.info.create_name}}.offset);
                    {%- when BackendTableFieldType::Other -%} table_writer.write({{field.vtable_index+1}}, &prepared_{{field.info.create_name}});
                    {%- endmatch -%}
                }
            {% endfor %}
        }
        {% endif %}

        table_writer.finish_calculating();
    }
}

impl planus::WriteAs<planus::Offset<{{info.owned_name}}>> for {{info.owned_name}} {
    fn prepare(&self, buffer: &mut planus::Buffer) -> planus::Offset<{{info.owned_name}}> {
        {{info.owned_name}}::create(
            buffer,
        {% for field in fields.declaration_order() %}
            &self.{{field.info.name}},
        {% endfor %}
        )
    }
}

impl planus::WriteAsOptional<planus::Offset<{{info.owned_name}}>> for {{info.owned_name}} {
    fn prepare(&self, buffer: &mut planus::Buffer) -> Option<planus::Offset<{{info.owned_name}}>> {
        Some(planus::WriteAs::prepare(self, buffer))
    }
}

#[derive(Copy, Clone)]
pub struct {{info.ref_name}}<'buf>(planus::table_reader::Table<'buf>);

impl<'buf> {{info.ref_name}} {
    {% for field in fields.declaration_order() %}
        pub fn {{field.info.name}}(&self) -> planus::Result<{{field.info.read_type}}> {
            {% if field.info.none_replacement.is_some() %} Ok( {% endif %}
            {% if field.field_type == BackendTableFieldType::UnionValue %}
            self.0.access_union({{field.vtable_index-1}}, "{{info.owned_name}}", "{{field.info.name}}")
            {% else %}
            self.0.access({{field.vtable_index}}, "{{info.owned_name}}", "{{field.info.name}}")
            {% endif %}
            {% match field.info.none_replacement %}
            {% when Some with (none_replacement) %}?.unwrap_or({{none_replacement}}))
            {% when None %}
            {% endmatch %}
        }
    {% endfor %}
}

impl<'buf> std::fmt::Debug for {{info.ref_name}} {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("{{info.ref_name}}");
        {% for field in fields.declaration_order() -%}
            {%- if field.info.read_type.starts_with("Option<") -%}
            if let Ok(Some({{field.info.name}})) = self.{{field.info.name}}() {
                f.field("{{field.info.name}}", &{{field.info.name}});
            }
            {%- else -%}
            if let Ok({{field.info.name}}) = self.{{field.info.name}}() {
                f.field("{{field.info.name}}", &{{field.info.name}});
            }
            {%- endif -%}
        {%- endfor %}
        f.finish()
    }
}
